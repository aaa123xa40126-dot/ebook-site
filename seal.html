<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>封印之地｜種子的見證者</title>
<meta name="description" content="種子的見證者" />
<style>
  :root{ --bg1:#120806; --bg2:#1b0d0a; }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0}
  body{
    background: radial-gradient(1400px 900px at 50% 45%, var(--bg2) 0%, var(--bg1) 65%, #090605 100%);
    color:#ffe9d6; font-family:"DFKai-SB","BiauKai",serif; overflow:hidden;
  }
  #stage{position:fixed; inset:0; z-index:1;}
  .center-ui{
    position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
    flex-direction:column; gap:18px; z-index:9; pointer-events:none;
    text-align:center; padding:0 2rem;
  }
  .seal-wrap{position:relative; pointer-events:auto}
  .seal-line{
    position:relative; z-index:2;
    font-size:clamp(22px,4.4vmin,40px);
    letter-spacing:.02em;
    color:#ffe6cf;
    text-shadow:
      0 0 10px rgba(255,180,110,.55),
      0 0 28px rgba(255,140,80,.25);
  }
  .seal-wrap::before{
    content:""; position:absolute; inset:-12px -18px; z-index:1; border-radius:24px;
    background: radial-gradient(60% 100% at 50% 50%, rgba(255,200,140,.35), rgba(255,160,90,.18), rgba(255,120,60,.0) 70%);
    filter: blur(10px);
  }
  .seal-wrap::after{
    content:""; position:absolute; inset:-20px -26px; z-index:0; border-radius:28px;
    background: radial-gradient(70% 120% at 50% 50%, rgba(255,210,160,.20), rgba(255,150,80,.12), rgba(255,120,60,.0) 70%);
    filter: blur(16px);
    animation: breathe 6s ease-in-out infinite;
  }
  @keyframes breathe{ 0%,100%{opacity:.8} 50%{opacity:1.1} }
  .btns{display:flex; gap:14px; justify-content:center; pointer-events:auto}
  .btn{
    padding:.72rem 1.24rem; border-radius:12px; text-decoration:none; color:#1b0a05;
    border:1px solid rgba(255,190,140,.45);
    background:linear-gradient(180deg,#ffe6cf,#ffd1ab 60%,#ffb170);
    box-shadow:inset 0 1px 0 rgba(255,255,255,.55),0 6px 18px rgba(255,120,50,.22);
    transition:transform .12s ease, box-shadow .18s ease, filter .18s ease, border-color .18s ease;
  }
  .btn:hover{filter:brightness(1.06); transform:translateY(-1px); border-color:rgba(255,200,150,.85);
    box-shadow:inset 0 1px 0 rgba(255,255,255,.7),0 10px 26px rgba(255,150,80,.35),0 0 22px rgba(255,160,90,.35);}
</style>
</head>
<body>
  <canvas id="stage"></canvas>
  <div class="center-ui">
    <div class="seal-wrap">
      <div class="seal-line">燃起心之火者，方能窺見此地的低語。</div>
    </div>
    <div class="btns">
      <a class="btn" href="main.html" id="btnMain">回到首頁購買</a>
      <a class="btn" href="unlock.html" id="btnUnlock">輸入火種序號</a>
    </div>
  </div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.152.2/build/three.module.js";

const canvas = document.getElementById('stage');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
renderer.setSize(innerWidth, innerHeight);
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 4000);
camera.position.set(0, 0, 48);

function makeGlowTexture(){
  const s = 128;
  const c = document.createElement('canvas'); c.width = c.height = s;
  const g = c.getContext('2d');
  const grd = g.createRadialGradient(s/2,s/2,0, s/2,s/2,s/2);
  grd.addColorStop(0.0,'rgba(255,230,180,1)');
  grd.addColorStop(0.35,'rgba(255,180,110,0.8)');
  grd.addColorStop(0.7,'rgba(255,150,80,0.18)');
  grd.addColorStop(1.0,'rgba(255,120,50,0)');
  g.fillStyle = grd; g.fillRect(0,0,s,s);
  const tex = new THREE.CanvasTexture(c);
  tex.minFilter=THREE.LinearFilter; tex.magFilter=THREE.LinearFilter;
  return tex;
}
const glowTex = makeGlowTexture();
const world = new THREE.Group(); scene.add(world);
const warmPalette = [0xffb06a, 0xff8a50, 0xff7240, 0xffcc7a];
function makeOrbit(radius, tx, ty, speed, count, size, opacity){
  const g = new THREE.Group(); g.rotation.set(tx,ty,0); world.add(g);
  const hue = warmPalette[(Math.random()*warmPalette.length)|0];
  const mat = new THREE.SpriteMaterial({map:glowTex, color:hue, blending:THREE.AdditiveBlending, depthWrite:false, transparent:true, opacity});
  const sprites=[];
  for(let i=0;i<count;i++){
    const a=Math.random()*Math.PI*2;
    const spr=new THREE.Sprite(mat.clone());
    spr.scale.setScalar(size*(0.7+Math.random()*0.5));
    spr.userData={a, jitter:(Math.random()*0.6-0.3)};
    g.add(spr); sprites.push(spr);
  }
  function update(dt, t){
    g.rotation.z += speed*dt*0.02;
    for(const s of sprites){
      s.userData.a += speed*dt*0.12;
      const a = s.userData.a;
      s.position.set(Math.cos(a)*radius, Math.sin(a)*radius, 0);
      const breath = 1.0 + 0.04*Math.sin(t*0.6 + s.userData.jitter*10);
      s.scale.setScalar(size*breath);
    }
  }
  return {group:g, update};
}
const orbits=[
  makeOrbit(13.5,0.25,0.2,0.006,160,1.1,0.36),
  makeOrbit(18.0,-0.35,0.6,-0.005,180,1.2,0.34),
  makeOrbit(22.8,0.55,-0.15,0.0045,200,1.25,0.32),
  makeOrbit(27.4,-0.9,0.45,-0.004,220,1.3,0.30),
  makeOrbit(33.6,0.3,0.9,0.0036,220,1.35,0.30),
  makeOrbit(39.0,-0.5,-0.8,0.0032,240,1.4,0.28),
  makeOrbit(46.0,0.8,0.2,-0.003,260,1.45,0.26)
];

const P_COUNT = 6000;
const pGeom = new THREE.BufferGeometry();
const pPos = new Float32Array(P_COUNT*3);
const pBase = new Float32Array(P_COUNT*3);
for(let i=0;i<P_COUNT;i++){
  const R = 50*Math.random()+30;
  const theta = Math.random()*Math.PI*2;
  const phi = Math.acos(2*Math.random()-1);
  const x = R * Math.sin(phi) * Math.cos(theta);
  const y = R * Math.sin(phi) * Math.sin(theta);
  const z = R * Math.cos(phi);
  pPos.set([x,y,z], i*3);
  pBase.set([x,y,z], i*3);
}
pGeom.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
const pMat = new THREE.PointsMaterial({size:0.55, map:glowTex, color:0xffb06a, transparent:true, opacity:0.45, depthWrite:false, blending:THREE.AdditiveBlending});
const particles = new THREE.Points(pGeom, pMat); scene.add(particles);

let mx=0,my=0;
window.addEventListener('pointermove', e=>{mx=(e.clientX/innerWidth)*2-1; my=-(e.clientY/innerHeight)*2+1;}, {passive:true});
const raycaster=new THREE.Raycaster();
const planeZ=new THREE.Plane(new THREE.Vector3(0,0,1),0);
const mouseWorld=new THREE.Vector3();

function updateParticles(dt, attractPoint){
  const arr=pGeom.attributes.position.array;
  for(let i=0;i<P_COUNT;i++){
    const ix=i*3; let x=arr[ix], y=arr[ix+1], z=arr[ix+2];
    const bx=pBase[ix], by=pBase[ix+1], bz=pBase[ix+2];
    x+=(bx-x)*0.0005*dt; y+=(by-y)*0.0005*dt; z+=(bz-z)*0.0005*dt;
    if(attractPoint){
      const dx=attractPoint.x-x, dy=attractPoint.y-y, dz=attractPoint.z-z;
      const dist=Math.hypot(dx,dy,dz)+0.0001;
      if(dist<22){const f=(22-dist)/22; x+=dx*f*0.05*dt; y+=dy*f*0.05*dt; z+=dz*f*0.05*dt;}
    }
    const ang=0.0006*dt, cs=Math.cos(ang), sn=Math.sin(ang);
    const nx=x*cs+z*sn, nz=-x*sn+z*cs;
    arr[ix]=nx; arr[ix+1]=y; arr[ix+2]=nz;
  }
  pGeom.attributes.position.needsUpdate=true;
}

let last=performance.now();
function tick(){
  const now=performance.now(); const dt=Math.min(60,now-last)/16.6667; last=now;
  const t=now/1000;
  world.rotation.y+=0.0006*dt;
  orbits.forEach(o=>o.update(dt,t));
  raycaster.setFromCamera({x:mx,y:my},camera);
  raycaster.ray.intersectPlane(planeZ,mouseWorld);
  updateParticles(dt,mouseWorld);
  pMat.opacity=0.42+0.06*Math.sin(t*0.7);
  renderer.render(scene,camera);
  requestAnimationFrame(tick);
}
tick();

// ---- 音效控制：循環播放 seal_energy.mp3 ----
let humAudio=null;
function startSealHum(){
  if(humAudio)return;
  humAudio=new Audio("seal_energy.mp3");
  humAudio.loop=true;
  humAudio.volume=0.6;
  humAudio.play().catch(()=>{});
}
// 任何互動皆啟動音效
window.addEventListener('pointerdown',startSealHum,{once:true});
window.addEventListener('keydown',startSealHum,{once:true});
</script>
</body>
</html>
